/* Generated by JTB 1.4.9 */
package visitor;

import java.util.ArrayList;
import java.util.Arrays;

import grammar.syntaxtree.AddExp;
import grammar.syntaxtree.Bound;
import grammar.syntaxtree.Exp;
import grammar.syntaxtree.FuncDef;
import grammar.syntaxtree.INode;
import grammar.syntaxtree.InputSection;
import grammar.syntaxtree.ItemExp;
import grammar.syntaxtree.Literal;
import grammar.syntaxtree.LogExp;
import grammar.syntaxtree.MulExp;
import grammar.syntaxtree.NodeChoice;
import grammar.syntaxtree.NodeList;
import grammar.syntaxtree.NodeListOptional;
import grammar.syntaxtree.NodeOptional;
import grammar.syntaxtree.NodeSequence;
import grammar.syntaxtree.NodeToken;
import grammar.syntaxtree.ObjectiveSection;
import grammar.syntaxtree.OutputSection;
import grammar.syntaxtree.PowExp;
import grammar.syntaxtree.PrimType;
import grammar.syntaxtree.RelExp;
import grammar.syntaxtree.RequiredSection;
import grammar.syntaxtree.Start;
import grammar.syntaxtree.Type;
import grammar.syntaxtree.VarDef;
import grammar.syntaxtree.VarList;
import grammar.visitor.DepthFirstRetVisitor;
import type.ExpTreeNode;
import type.ExpTreeNode.Operator;
import type.VarRecord;
import type.VarTable;
import type.VarTable.Objective;
import type.VarRecord.VarClass;
import type.vartype.VarTypeArray;
import type.vartype.VarTypeBool;
import type.vartype.VarTypeChar;
import type.vartype.VarTypeInt;
import type.vartype.VarTypeReal;

public class ExpTreeBuilderVisitor extends DepthFirstRetVisitor<ExpTreeNode> {

	private VarTable varTable;
	private ArrayList<ExpTreeNode> expTrees;
	private VarRecord.VarClass varClass;
	private ArrayList<Integer> suffix = new ArrayList<Integer>(Arrays.asList(0));
	private int sumCnt = 0;

	public ExpTreeBuilderVisitor(VarTable varTable, ArrayList<ExpTreeNode> expTrees) {
		this.varTable = varTable;
		this.expTrees = expTrees;
	}

	private String getVarFullName(String varName, boolean newDef) {
		String ret = null;
		int length = suffix.size();
		for (int i = 0; i < length; i++) {
			if (varTable.get(varName) != null)
				ret = varName;
			if (i < length - 1)
				varName += "_" + suffix.get(i);
		}
		if (newDef || ret == null)
			return varName;
		else
			return ret;
	}

	private VarRecord genVar(NodeToken n, VarRecord.VarClass varClass, boolean newDef) {
		if (suffix.size() > 1)
			varClass = VarClass.LOCAL;
		return varTable.newVar(getVarFullName(n.tokenImage, newDef), varClass);
	}

	public void pushSuffix() {
		int length = suffix.size();
		suffix.set(length - 1, suffix.get(length - 1) + 1);
		suffix.add(0);
	}

	public void popSuffix() {
		int length = suffix.size();
		suffix.remove(length - 1);
	}

	/*
	 * User grammar generated visit methods (to be overridden if necessary)
	 */

	/**
	 * Visits a {@link Start} node, whose children are the following :
	 * <p>
	 * f0 -> [ InputSection() ]<br>
	 * f1 -> [ RequiredSection() ]<br>
	 * f2 -> [ ObjectiveSection() ]<br>
	 * f3 -> [ OutputSection() ]<br>
	 * f4 -> < EOF ><br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final Start n) {
		ExpTreeNode nRes = null;
		// f0 -> [ InputSection() ]
		final NodeOptional n0 = n.f0;
		if (n0.present()) {
			nRes = n0.accept(this);
		}
		// f1 -> [ RequiredSection() ]
		final NodeOptional n1 = n.f1;
		if (n1.present()) {
			nRes = n1.accept(this);
		}
		// f2 -> [ ObjectiveSection() ]
		final NodeOptional n2 = n.f2;
		if (n2.present()) {
			nRes = n2.accept(this);
		}
		// f3 -> [ OutputSection() ]
		final NodeOptional n3 = n.f3;
		if (n3.present()) {
			nRes = n3.accept(this);
		}
		// f4 -> < EOF >
		final NodeToken n4 = n.f4;
		nRes = n4.accept(this);
		return nRes;
	}

	/**
	 * Visits a {@link InputSection} node, whose children are the following :
	 * <p>
	 * f0 -> < INPUT ><br>
	 * f1 -> ( #0 VarDef() #1 ";" )*<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final InputSection n) {
		ExpTreeNode nRes = null;
		// f0 -> < INPUT >
		final NodeToken n0 = n.f0;
		nRes = n0.accept(this);
		// f1 -> ( #0 VarDef() #1 ";" )*
		final NodeListOptional n1 = n.f1;
		if (n1.present()) {
			varClass = VarClass.INPUT;
			for (int i = 0; i < n1.size(); i++) {
				final INode nloeai = n1.elementAt(i);
				final NodeSequence seq = (NodeSequence) nloeai;
				// #0 VarDef()
				final INode seq1 = seq.elementAt(0);
				nRes = seq1.accept(this);
				expTrees.add(nRes);
				// #1 ";"
				final INode seq2 = seq.elementAt(1);
				nRes = seq2.accept(this);
			}
		}
		return nRes;
	}

	/**
	 * Visits a {@link RequiredSection} node, whose children are the following :
	 * <p>
	 * f0 -> < REQUIRED ><br>
	 * f1 -> ( #0 Exp() #1 ";" )*<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final RequiredSection n) {
		ExpTreeNode nRes = null;
		// f0 -> < REQUIRED >
		final NodeToken n0 = n.f0;
		nRes = n0.accept(this);
		// f1 -> ( #0 Exp() #1 ";" )*
		final NodeListOptional n1 = n.f1;
		if (n1.present()) {
			varClass = VarClass.INDEPENDENT;
			for (int i = 0; i < n1.size(); i++) {
				final INode nloeai = n1.elementAt(i);
				final NodeSequence seq = (NodeSequence) nloeai;
				// #0 Exp()
				final INode seq1 = seq.elementAt(0);
				nRes = seq1.accept(this);
				expTrees.add(nRes);
				// #1 ";"
				final INode seq2 = seq.elementAt(1);
				nRes = seq2.accept(this);
			}
		}
		return nRes;
	}

	/**
	 * Visits a {@link ObjectiveSection} node, whose children are the following :
	 * <p>
	 * f0 -> < OBJECTIVE ><br>
	 * f1 -> [ #0 [ "@" ]<br>
	 * .. .. . #1 ( %0 < MINIMIZE ><br>
	 * .. .. . .. | %1 < MAXIMIZE > )<br>
	 * .. .. . #2 Exp() #3 ";" ]<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final ObjectiveSection n) {
		ExpTreeNode nRes = null;
		// f0 -> < OBJECTIVE >
		final NodeToken n0 = n.f0;
		nRes = n0.accept(this);
		// f1 -> [ #0 [ "@" ]
		// .. .. . #1 ( %0 < MINIMIZE >
		// .. .. . .. | %1 < MAXIMIZE > )
		// .. .. . #2 Exp() #3 ";" ]
		final NodeOptional n1 = n.f1;
		if (n1.present()) {
			VarRecord outputVar = varTable.newVar("_result", VarClass.INDEPENDENT);
			final NodeSequence seq = (NodeSequence) n1.node;
			// #0 [ "@" ]
			final INode seq1 = seq.elementAt(0);
			final NodeOptional opt = (NodeOptional) seq1;
			if (opt.present()) {
				nRes = opt.accept(this);
			} else
				varTable.addOutput("_result");
			// #1 ( %0 < MINIMIZE >
			// .. | %1 < MAXIMIZE > )
			final INode seq2 = seq.elementAt(1);
			final NodeChoice nch = (NodeChoice) seq2;
			final INode ich = nch.choice;
			ExpTreeNode expTree = null;
			switch (nch.which) {
			case 0:
				// %0 < MINIMIZE >
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.MINIMIZE);
				varTable.setObjective(Objective.MIN);
				break;
			case 1:
				// %1 < MAXIMIZE >
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.MAXIMIZE);
				varTable.setObjective(Objective.MAX);
				break;
			default:
				// should not occur !!!
				break;
			}
			// #2 Exp()
			final INode seq3 = seq.elementAt(2);
			nRes = seq3.accept(this);
			expTree.add(nRes);
			expTrees.add(new ExpTreeNode(Operator.EQUAL, new ExpTreeNode(outputVar), expTree));
			// #3 ";"
			final INode seq4 = seq.elementAt(3);
			nRes = seq4.accept(this);
		}
		return nRes;
	}

	/**
	 * Visits a {@link OutputSection} node, whose children are the following :
	 * <p>
	 * f0 -> < OUTPUT ><br>
	 * f1 -> ( #0 Exp() #1 ";" )*<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final OutputSection n) {
		ExpTreeNode nRes = null;
		// f0 -> < OUTPUT >
		final NodeToken n0 = n.f0;
		nRes = n0.accept(this);
		// f1 -> ( #0 Exp() #1 ";" )*
		final NodeListOptional n1 = n.f1;
		if (n1.present()) {
			for (int i = 0; i < n1.size(); i++) {
				final INode nloeai = n1.elementAt(i);
				final NodeSequence seq = (NodeSequence) nloeai;
				// #0 Exp()
				final INode seq1 = seq.elementAt(0);
				nRes = seq1.accept(this);
				if (nRes.getOp() == Operator.NONE)
					varTable.addOutput(nRes.getStr());
				else {
					VarRecord v = varTable.newVar("_out" + i, VarClass.INDEPENDENT);
					expTrees.add(new ExpTreeNode(Operator.EQUAL, new ExpTreeNode(v), nRes));
					varTable.addOutput("_out" + i);
				}
				// #1 ";"
				final INode seq2 = seq.elementAt(1);
				nRes = seq2.accept(this);
			}
		}
		return nRes;
	}

	/**
	 * Visits a {@link VarDef} node, whose children are the following :
	 * <p>
	 * f0 -> < IDENTIFIER ><br>
	 * f1 -> < OF ><br>
	 * f2 -> Type()<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final VarDef n) {
		ExpTreeNode nRes = null;
		// f0 -> < IDENTIFIER >
		final NodeToken n0 = n.f0;
		nRes = n0.accept(this);
		// f1 -> < OF >
		final NodeToken n1 = n.f1;
		nRes = n1.accept(this);
		// f2 -> Type()
		final Type n2 = n.f2;
		nRes = n2.accept(this);
		VarRecord var = genVar(n0, varClass, true);
		var.setDefExp(nRes);
		return new ExpTreeNode(Operator.OF, new ExpTreeNode(var), nRes);
	}

	/**
	 * Visits a {@link Type} node, whose children are the following :
	 * <p>
	 * f0 -> ( %0 PrimType()<br>
	 * .. .. | %1 #0 "(" #1 Type()<br>
	 * .. .. . .. #2 ( $0 "," $1 Type() )*<br>
	 * .. .. . .. #3 ")" )<br>
	 * f1 -> ( ( %0 #0 "["<br>
	 * .. .. . . .. #1 [ $0 Bound() $1 "~" $2 Bound() ]<br>
	 * .. .. . . .. #2 "]"<br>
	 * .. .. . | %1 #0 "{" #1 "}" ) )*<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final Type n) {
		ExpTreeNode nRes = null;
		// f0 -> ( %0 PrimType()
		// .. .. | %1 #0 "(" #1 Type()
		// .. .. . .. #2 ( $0 "," $1 Type() )*
		// .. .. . .. #3 ")" )
		final NodeChoice n0 = n.f0;
		final NodeChoice nch = n0;
		final INode ich = nch.choice;
		ExpTreeNode expTree = null;
		switch (nch.which) {
		case 0:
			// %0 PrimType()
			nRes = ich.accept(this);
			expTree = nRes;
			break;
		case 1:
			// %1 #0 "(" #1 Type()
			// .. #2 ( $0 "," $1 Type() )*
			// .. #3 ")"
			final NodeSequence seq = (NodeSequence) ich;
			// #0 "("
			final INode seq1 = seq.elementAt(0);
			nRes = seq1.accept(this);
			// #1 Type()
			final INode seq2 = seq.elementAt(1);
			nRes = seq2.accept(this);
			// #2 ( $0 "," $1 Type() )*
			final INode seq3 = seq.elementAt(2);
			final NodeListOptional nlo = (NodeListOptional) seq3;
			if (nlo.present()) {
				expTree = new ExpTreeNode(Operator.TUPLE, nRes);
				for (int i = 0; i < nlo.size(); i++) {
					final INode nloeai = nlo.elementAt(i);
					final NodeSequence seq4 = (NodeSequence) nloeai;
					// $0 ","
					final INode seq5 = seq4.elementAt(0);
					nRes = seq5.accept(this);
					// $1 Type()
					final INode seq6 = seq4.elementAt(1);
					nRes = seq6.accept(this);
					expTree.add(nRes);
				}
			} else
				expTree = nRes;
			// #3 ")"
			final INode seq7 = seq.elementAt(3);
			nRes = seq7.accept(this);
			break;
		default:
			// should not occur !!!
			break;
		}
		// f1 -> ( ( %0 #0 "["
		// .. .. . . .. #1 [ $0 Bound() $1 "~" $2 Bound() ]
		// .. .. . . .. #2 "]"
		// .. .. . | %1 #0 "{" #1 "}" ) )*
		final NodeListOptional n1 = n.f1;
		if (n1.present()) {
			for (int i = 0; i < n1.size(); i++) {
				final INode nloeai = n1.elementAt(i);
				final NodeChoice nch1 = (NodeChoice) nloeai;
				final INode ich1 = nch1.choice;
				switch (nch1.which) {
				case 0:
					// %0 #0 "["
					// .. #1 [ $0 Bound() $1 "~" $2 Bound() ]
					// .. #2 "]"
					expTree = new ExpTreeNode(Operator.ARRAY, expTree);
					final NodeSequence seq8 = (NodeSequence) ich1;
					// #0 "["
					final INode seq9 = seq8.elementAt(0);
					nRes = seq9.accept(this);
					// #1 [ $0 Bound() $1 "~" $2 Bound() ]
					final INode seq10 = seq8.elementAt(1);
					final NodeOptional opt = (NodeOptional) seq10;
					if (opt.present()) {
						final NodeSequence seq11 = (NodeSequence) opt.node;
						// $0 Bound()
						final INode seq12 = seq11.elementAt(0);
						nRes = seq12.accept(this);
						expTree.add(nRes);
						// $1 "~"
						final INode seq13 = seq11.elementAt(1);
						nRes = seq13.accept(this);
						// $2 Bound()
						final INode seq14 = seq11.elementAt(2);
						nRes = seq14.accept(this);
						expTree.add(nRes);
					}
					// #2 "]"
					final INode seq15 = seq8.elementAt(2);
					nRes = seq15.accept(this);
					break;
				case 1:
					// %1 #0 "{" #1 "}"
					expTree = new ExpTreeNode(Operator.SET, expTree);
					final NodeSequence seq16 = (NodeSequence) ich1;
					// #0 "{"
					final INode seq17 = seq16.elementAt(0);
					nRes = seq17.accept(this);
					// #1 "}"
					final INode seq18 = seq16.elementAt(1);
					nRes = seq18.accept(this);
					break;
				default:
					// should not occur !!!
					break;
				}
			}
		}
		return expTree;
	}

	/**
	 * Visits a {@link PrimType} node, whose children are the following :
	 * <p>
	 * f0 -> ( %0 < INT ><br>
	 * .. .. | %1 < REAL ><br>
	 * .. .. | %2 < BOOL ><br>
	 * .. .. | %3 < CHAR > )<br>
	 * f1 -> [ #0 < IN > #1 "[" #2 Bound() #3 "," #4 Bound() #5 "]" ]<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final PrimType n) {
		ExpTreeNode nRes = null;
		// f0 -> ( %0 < INT >
		// .. .. | %1 < REAL >
		// .. .. | %2 < BOOL >
		// .. .. | %3 < CHAR > )
		final NodeChoice n0 = n.f0;
		final NodeChoice nch = n0;
		final INode ich = nch.choice;
		ExpTreeNode expTree = null;
		switch (nch.which) {
		case 0:
			// %0 < INT >
			nRes = ich.accept(this);
			expTree = new ExpTreeNode(Operator.INT);
			break;
		case 1:
			// %1 < REAL >
			nRes = ich.accept(this);
			expTree = new ExpTreeNode(Operator.REAL);
			break;
		case 2:
			// %2 < BOOL >
			nRes = ich.accept(this);
			expTree = new ExpTreeNode(Operator.BOOL);
			break;
		case 3:
			// %3 < CHAR >
			nRes = ich.accept(this);
			expTree = new ExpTreeNode(Operator.CHAR);
			break;
		default:
			// should not occur !!!
			break;
		}
		// f1 -> [ #0 < IN > #1 "[" #2 Bound() #3 "," #4 Bound() #5 "]" ]
		final NodeOptional n1 = n.f1;
		if (n1.present()) {
			final NodeSequence seq = (NodeSequence) n1.node;
			// #0 < IN >
			final INode seq1 = seq.elementAt(0);
			nRes = seq1.accept(this);
			// #1 "["
			final INode seq2 = seq.elementAt(1);
			nRes = seq2.accept(this);
			// #2 Bound()
			final INode seq3 = seq.elementAt(2);
			nRes = seq3.accept(this);
			expTree.add(nRes);
			// #3 ","
			final INode seq4 = seq.elementAt(3);
			nRes = seq4.accept(this);
			// #4 Bound()
			final INode seq5 = seq.elementAt(4);
			nRes = seq5.accept(this);
			expTree.add(nRes);
			// #5 "]"
			final INode seq6 = seq.elementAt(5);
			nRes = seq6.accept(this);
		} else {
			expTree.add(null);
			expTree.add(null);
		}
		return expTree;
	}

	/**
	 * Visits a {@link Bound} node, whose child is the following :
	 * <p>
	 * f0 -> . %0 Exp()<br>
	 * .. .. | %1 "?"<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final Bound n) {
		ExpTreeNode nRes = null;
		// f0 -> . %0 Exp()
		// .. .. | %1 "?"
		final NodeChoice nch = n.f0;
		final INode ich = nch.choice;
		switch (nch.which) {
		case 0:
			// %0 Exp()
			nRes = ich.accept(this);
			break;
		case 1:
			// %1 "?"
			nRes = ich.accept(this);
			break;
		default:
			// should not occur !!!
			break;
		}
		return nRes;
	}

	/**
	 * Visits a {@link FuncDef} node, whose children are the following :
	 * <p>
	 * f0 -> < IDENTIFIER ><br>
	 * f1 -> < OF ><br>
	 * f2 -> < FUNCTION ><br>
	 * f3 -> VarList()<br>
	 * f4 -> "->"<br>
	 * f5 -> Type()<br>
	 * f6 -> "="<br>
	 * f7 -> Exp()<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final FuncDef n) {
		ExpTreeNode nRes = null;
		// f0 -> < IDENTIFIER >
		final NodeToken n0 = n.f0;
		nRes = n0.accept(this);
		VarRecord var = genVar(n0, VarClass.FUNCTION, true);
		// f1 -> < OF >
		final NodeToken n1 = n.f1;
		nRes = n1.accept(this);
		// f2 -> < FUNCTION >
		final NodeToken n2 = n.f2;
		nRes = n2.accept(this);
		pushSuffix();
		ExpTreeNode expTree = new ExpTreeNode(Operator.FUNCTION);
		// f3 -> VarList()
		final VarList n3 = n.f3;
		nRes = n3.accept(this);
		expTree.add(nRes);
		// f4 -> "->"
		final NodeToken n4 = n.f4;
		nRes = n4.accept(this);
		// f5 -> Type()
		final Type n5 = n.f5;
		nRes = n5.accept(this);
		expTree.add(nRes);
		// f6 -> "="
		final NodeToken n6 = n.f6;
		nRes = n6.accept(this);
		// f7 -> Exp()
		final Exp n7 = n.f7;
		nRes = n7.accept(this);
		expTree.add(nRes);
		popSuffix();
		return new ExpTreeNode(Operator.OF, new ExpTreeNode(var), expTree);
	}

	/**
	 * Visits a {@link VarList} node, whose child is the following :
	 * <p>
	 * f0 -> . %0 < IDENTIFIER ><br>
	 * .. .. | %1 #0 "("<br>
	 * .. .. . .. #1 ( &0 VarDef()<br>
	 * .. .. . .. .. | &1 < IDENTIFIER > )<br>
	 * .. .. . .. #2 ( $0 ","<br>
	 * .. .. . .. .. . $1 ( &0 VarDef()<br>
	 * .. .. . .. .. . .. | &1 < IDENTIFIER > ) )*<br>
	 * .. .. . .. #3 ")"<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final VarList n) {
		ExpTreeNode nRes = null;
		// f0 -> . %0 < IDENTIFIER >
		// .. .. | %1 #0 "("
		// .. .. . .. #1 ( &0 VarDef()
		// .. .. . .. .. | &1 < IDENTIFIER > )
		// .. .. . .. #2 ( $0 ","
		// .. .. . .. .. . $1 ( &0 VarDef()
		// .. .. . .. .. . .. | &1 < IDENTIFIER > ) )*
		// .. .. . .. #3 ")"
		final NodeChoice nch = n.f0;
		final INode ich = nch.choice;
		ExpTreeNode expTree = new ExpTreeNode(Operator.TUPLE);
		switch (nch.which) {
		case 0:
			// %0 < IDENTIFIER >
			nRes = ich.accept(this);
			expTree.add(new ExpTreeNode(genVar((NodeToken) ich, varClass, true)));
			break;
		case 1:
			// %1 #0 "("
			// .. #1 ( &0 VarDef()
			// .. .. | &1 < IDENTIFIER > )
			// .. #2 ( $0 ","
			// .. .. . $1 ( &0 VarDef()
			// .. .. . .. | &1 < IDENTIFIER > ) )*
			// .. #3 ")"
			final NodeSequence seq = (NodeSequence) ich;
			// #0 "("
			final INode seq1 = seq.elementAt(0);
			nRes = seq1.accept(this);
			// #1 ( &0 VarDef()
			// .. | &1 < IDENTIFIER > )
			final INode seq2 = seq.elementAt(1);
			final NodeChoice nch1 = (NodeChoice) seq2;
			final INode ich1 = nch1.choice;
			switch (nch1.which) {
			case 0:
				// &0 VarDef()
				nRes = ich1.accept(this);
				expTree.add(nRes);
				break;
			case 1:
				// &1 < IDENTIFIER >
				nRes = ich1.accept(this);
				expTree.add(new ExpTreeNode(genVar((NodeToken) ich1, varClass, true)));
				break;
			default:
				// should not occur !!!
				break;
			}
			// #2 ( $0 ","
			// .. . $1 ( &0 VarDef()
			// .. . .. | &1 < IDENTIFIER > ) )*
			final INode seq3 = seq.elementAt(2);
			final NodeListOptional nlo = (NodeListOptional) seq3;
			if (nlo.present()) {
				for (int i = 0; i < nlo.size(); i++) {
					final INode nloeai = nlo.elementAt(i);
					final NodeSequence seq4 = (NodeSequence) nloeai;
					// $0 ","
					final INode seq5 = seq4.elementAt(0);
					nRes = seq5.accept(this);
					// $1 ( &0 VarDef()
					// .. | &1 < IDENTIFIER > )
					final INode seq6 = seq4.elementAt(1);
					final NodeChoice nch2 = (NodeChoice) seq6;
					final INode ich2 = nch2.choice;
					switch (nch2.which) {
					case 0:
						// &0 VarDef()
						nRes = ich2.accept(this);
						expTree.add(nRes);
						break;
					case 1:
						// &1 < IDENTIFIER >
						nRes = ich2.accept(this);
						expTree.add(new ExpTreeNode(genVar((NodeToken) ich2, varClass, true)));
						break;
					default:
						// should not occur !!!
						break;
					}
				}
			}
			// #3 ")"
			final INode seq7 = seq.elementAt(3);
			nRes = seq7.accept(this);
			break;
		default:
			// should not occur !!!
			break;
		}
		return expTree;
	}

	/**
	 * Visits a {@link Exp} node, whose child is the following :
	 * <p>
	 * f0 -> . %0 ( &0 VarDef()<br>
	 * .. .. . .. | &1 FuncDef() )<br>
	 * .. .. | %1 #0 LogExp()<br>
	 * .. .. . .. #1 [ $0 ":" $1 < FORALL > $2 VarList()<br>
	 * .. .. . .. .. . $3 [ ?0 "(" ?1 Exp() ?2 ")" ] ]<br>
	 * .. .. | %2 #0 < EXISTS > #1 VarList() #2 "(" #3 Exp() #4 ")"<br>
	 * .. .. | %3 #0 < IF > #1 "(" #2 Exp() #3 ")" #4 "(" #5 Exp() #6 ")"<br>
	 * .. .. . .. #7 [ $0 < ELSE > $1 "(" $2 Exp() $3 ")" ]<br>
	 * .. .. | %4 #0 < ALLDIFF > #1 Exp()<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final Exp n) {
		ExpTreeNode nRes = null;
		// f0 -> . %0 ( &0 VarDef()
		// .. .. . .. | &1 FuncDef() )
		// .. .. | %1 #0 LogExp()
		// .. .. . .. #1 [ $0 ":" $1 < FORALL > $2 VarList()
		// .. .. . .. .. . $3 [ ?0 "(" ?1 Exp() ?2 ")" ] ]
		// .. .. | %2 #0 < EXISTS > #1 VarList() #2 "(" #3 Exp() #4 ")"
		// .. .. | %3 #0 < IF > #1 "(" #2 Exp() #3 ")" #4 "(" #5 Exp() #6 ")"
		// .. .. . .. #7 [ $0 < ELSE > $1 "(" $2 Exp() $3 ")" ]
		// .. .. | %4 #0 < ALLDIFF > #1 Exp()
		final NodeChoice nch = n.f0;
		final INode ich = nch.choice;
		ExpTreeNode expTree = null;
		switch (nch.which) {
		case 0:
			// %0 ( &0 VarDef()
			// .. | &1 FuncDef() )
			final NodeChoice nch1 = (NodeChoice) ich;
			final INode ich1 = nch1.choice;
			switch (nch1.which) {
			case 0:
				// &0 VarDef()
				nRes = ich1.accept(this);
				expTree = nRes;
				break;
			case 1:
				// &1 FuncDef()
				nRes = ich1.accept(this);
				expTree = nRes;
				break;
			default:
				// should not occur !!!
				break;
			}
			break;
		case 1:
			// %1 #0 LogExp()
			// .. #1 [ $0 ":" $1 < FORALL > $2 VarList()
			// .. .. . $3 [ ?0 "(" ?1 Exp() ?2 ")" ] ]
			final NodeSequence seq = (NodeSequence) ich;
			// #0 LogExp()
			final INode seq1 = seq.elementAt(0);
			// #1 [ $0 ":" $1 < FORALL > $2 VarList()
			// .. . $3 [ ?0 "(" ?1 Exp() ?2 ")" ] ]
			final INode seq2 = seq.elementAt(1);
			final NodeOptional opt = (NodeOptional) seq2;
			if (opt.present()) {
				pushSuffix();
				expTree = new ExpTreeNode(Operator.FORALL);
				final NodeSequence seq3 = (NodeSequence) opt.node;
				// $0 ":"
				final INode seq4 = seq3.elementAt(0);
				nRes = seq4.accept(this);
				// $1 < FORALL >
				final INode seq5 = seq3.elementAt(1);
				nRes = seq5.accept(this);
				// $2 VarList()
				final INode seq6 = seq3.elementAt(2);
				nRes = seq6.accept(this);
				expTree.add(nRes);
				// $3 [ ?0 "(" ?1 Exp() ?2 ")" ]
				final INode seq7 = seq3.elementAt(3);
				final NodeOptional opt1 = (NodeOptional) seq7;
				if (opt1.present()) {
					final NodeSequence seq8 = (NodeSequence) opt1.node;
					// ?0 "("
					final INode seq9 = seq8.elementAt(0);
					nRes = seq9.accept(this);
					// ?1 Exp()
					final INode seq10 = seq8.elementAt(1);
					nRes = seq10.accept(this);
					expTree.add(nRes);
					// ?2 ")"
					final INode seq11 = seq8.elementAt(2);
					nRes = seq11.accept(this);
				} else
					expTree.add(null);
			}
			nRes = seq1.accept(this);
			if (opt.present()) {
				expTree.add(nRes);
				popSuffix();
			} else
				expTree = nRes;
			break;
		case 2:
			// %2 #0 < EXISTS > #1 VarList() #2 "(" #3 Exp() #4 ")"
			final NodeSequence seq12 = (NodeSequence) ich;
			// #0 < EXISTS >
			final INode seq13 = seq12.elementAt(0);
			nRes = seq13.accept(this);
			pushSuffix();
			expTree = new ExpTreeNode(Operator.EXISTS);
			// #1 VarList()
			final INode seq14 = seq12.elementAt(1);
			nRes = seq14.accept(this);
			expTree.add(nRes);
			// #2 "("
			final INode seq15 = seq12.elementAt(2);
			nRes = seq15.accept(this);
			// #3 Exp()
			final INode seq16 = seq12.elementAt(3);
			nRes = seq16.accept(this);
			expTree.add(nRes);
			// #4 ")"
			final INode seq17 = seq12.elementAt(4);
			nRes = seq17.accept(this);
			popSuffix();
			break;
		case 3:
			// %3 #0 < IF > #1 "(" #2 Exp() #3 ")" #4 "(" #5 Exp() #6 ")"
			// .. #7 [ $0 < ELSE > $1 "(" $2 Exp() $3 ")" ]
			final NodeSequence seq18 = (NodeSequence) ich;
			// #0 < IF >
			final INode seq19 = seq18.elementAt(0);
			nRes = seq19.accept(this);
			// #1 "("
			final INode seq20 = seq18.elementAt(1);
			nRes = seq20.accept(this);
			// #2 Exp()
			final INode seq21 = seq18.elementAt(2);
			nRes = seq21.accept(this);
			expTree = new ExpTreeNode(Operator.IF, nRes);
			// #3 ")"
			final INode seq22 = seq18.elementAt(3);
			nRes = seq22.accept(this);
			// #4 "("
			final INode seq23 = seq18.elementAt(4);
			nRes = seq23.accept(this);
			// #5 Exp()
			final INode seq24 = seq18.elementAt(5);
			nRes = seq24.accept(this);
			expTree.add(nRes);
			// #6 ")"
			final INode seq25 = seq18.elementAt(6);
			nRes = seq25.accept(this);
			// #7 [ $0 < ELSE > $1 "(" $2 Exp() $3 ")" ]
			final INode seq26 = seq18.elementAt(7);
			final NodeOptional opt2 = (NodeOptional) seq26;
			if (opt2.present()) {
				final NodeSequence seq27 = (NodeSequence) opt2.node;
				// $0 < ELSE >
				final INode seq28 = seq27.elementAt(0);
				nRes = seq28.accept(this);
				// $1 "("
				final INode seq29 = seq27.elementAt(1);
				nRes = seq29.accept(this);
				// $2 Exp()
				final INode seq30 = seq27.elementAt(2);
				nRes = seq30.accept(this);
				expTree.add(nRes);
				// $3 ")"
				final INode seq31 = seq27.elementAt(3);
				nRes = seq31.accept(this);
			} else
				expTree.add(null);
			break;
		case 4:
			// %4 #0 < ALLDIFF > #1 Exp()
			final NodeSequence seq32 = (NodeSequence) ich;
			// #0 < ALLDIFF >
			final INode seq33 = seq32.elementAt(0);
			nRes = seq33.accept(this);
			// #1 Exp()
			final INode seq34 = seq32.elementAt(1);
			nRes = seq34.accept(this);
			expTree = new ExpTreeNode(Operator.ALLDIFF, nRes);
			break;
		default:
			// should not occur !!!
			break;
		}
		return expTree;
	}

	/**
	 * Visits a {@link LogExp} node, whose children are the following :
	 * <p>
	 * f0 -> [ < NOT > ]<br>
	 * f1 -> RelExp()<br>
	 * f2 -> [ #0 ( %0 < AND ><br>
	 * .. .. . .. | %1 < OR ><br>
	 * .. .. . .. | %2 < XOR > )<br>
	 * .. .. . #1 LogExp() ]<br>
	 * 
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final LogExp n) {
		ExpTreeNode nRes = null;
		// f0 -> [ < NOT > ]
		final NodeOptional n0 = n.f0;
		if (n0.present()) {
			nRes = n0.accept(this);
		}
		// f1 -> RelExp()
		final RelExp n1 = n.f1;
		nRes = n1.accept(this);
		ExpTreeNode expTree = nRes;
		if (n0.present())
			expTree = new ExpTreeNode(Operator.NOT, expTree);
		// f2 -> [ #0 ( %0 < AND >
		// .. .. . .. | %1 < OR >
		// .. .. . .. | %2 < XOR > )
		// .. .. . #1 LogExp() ]
		final NodeOptional n2 = n.f2;
		if (n2.present()) {
			final NodeSequence seq = (NodeSequence) n2.node;
			// #0 ( %0 < AND >
			// .. | %1 < OR >
			// .. | %2 < XOR > )
			final INode seq1 = seq.elementAt(0);
			final NodeChoice nch = (NodeChoice) seq1;
			final INode ich = nch.choice;
			switch (nch.which) {
			case 0:
				// %0 < AND >
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.AND, expTree);
				break;
			case 1:
				// %1 < OR >
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.OR, expTree);
				break;
			case 2:
				// %2 < XOR >
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.XOR, expTree);
				break;
			default:
				// should not occur !!!
				break;
			}
			// #1 LogExp()
			final INode seq2 = seq.elementAt(1);
			nRes = seq2.accept(this);
			expTree.add(nRes);
		}
		return expTree;
	}

	/**
	 * Visits a {@link RelExp} node, whose children are the following :
	 * <p>
	 * f0 -> AddExp()<br>
	 * f1 -> [ #0 ( %0 "="<br>
	 * .. .. . .. | %1 "!="<br>
	 * .. .. . .. | %2 ">"<br>
	 * .. .. . .. | %3 "<"<br>
	 * .. .. . .. | %4 ">="<br>
	 * .. .. . .. | %5 "<="<br>
	 * .. .. . .. | %6 < IN > )<br>
	 * .. .. . #1 AddExp() ]<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final RelExp n) {
		ExpTreeNode nRes = null;
		// f0 -> AddExp()
		final AddExp n0 = n.f0;
		nRes = n0.accept(this);
		ExpTreeNode expTree = nRes;
		// f1 -> [ #0 ( %0 "="
		// .. .. . .. | %1 "!="
		// .. .. . .. | %2 ">"
		// .. .. . .. | %3 "<"
		// .. .. . .. | %4 ">="
		// .. .. . .. | %5 "<="
		// .. .. . .. | %6 < IN > )
		// .. .. . #1 AddExp() ]
		final NodeOptional n1 = n.f1;
		if (n1.present()) {
			final NodeSequence seq = (NodeSequence) n1.node;
			// #0 ( %0 "="
			// .. | %1 "!="
			// .. | %2 ">"
			// .. | %3 "<"
			// .. | %4 ">="
			// .. | %5 "<="
			// .. | %6 < IN > )
			final INode seq1 = seq.elementAt(0);
			final NodeChoice nch = (NodeChoice) seq1;
			final INode ich = nch.choice;
			switch (nch.which) {
			case 0:
				// %0 "="
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.EQUAL, expTree);
				break;
			case 1:
				// %1 "!="
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.NOTEQUAL, expTree);
				break;
			case 2:
				// %2 ">"
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.GREATER, expTree);
				break;
			case 3:
				// %3 "<"
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.LESS, expTree);
				break;
			case 4:
				// %4 ">="
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.GREATEREQUAL, expTree);
				break;
			case 5:
				// %5 "<="
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.LESSEQUAL, expTree);
				break;
			case 6:
				// %6 < IN >
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.IN, expTree);
				break;
			default:
				// should not occur !!!
				break;
			}
			// #1 AddExp()
			final INode seq2 = seq.elementAt(1);
			nRes = seq2.accept(this);
			expTree.add(nRes);
		}
		return expTree;
	}

	/**
	 * Visits a {@link AddExp} node, whose children are the following :
	 * <p>
	 * f0 -> [ %0 "+"<br>
	 * .. .. | %1 "-" ]<br>
	 * f1 -> MulExp()<br>
	 * f2 -> [ #0 ( %0 "+"<br>
	 * .. .. . .. | %1 "-" )<br>
	 * .. .. . #1 AddExp() ]<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final AddExp n) {
		ExpTreeNode nRes = null;
		// f0 -> [ %0 "+"
		// .. .. | %1 "-" ]
		final NodeOptional n0 = n.f0;
		boolean negative = false;
		if (n0.present()) {
			final NodeChoice nch = (NodeChoice) n0.node;
			final INode ich = nch.choice;
			switch (nch.which) {
			case 0:
				// %0 "+"
				nRes = ich.accept(this);
				break;
			case 1:
				// %1 "-"
				nRes = ich.accept(this);
				negative = true;
				break;
			default:
				// should not occur !!!
				break;
			}
		}
		// f1 -> MulExp()
		final MulExp n1 = n.f1;
		nRes = n1.accept(this);
		ExpTreeNode expTree = nRes;
		if (negative)
			expTree = new ExpTreeNode(Operator.SUBTRACT, new ExpTreeNode(new VarTypeInt("0"), "0"), expTree);
		// f2 -> [ #0 ( %0 "+"
		// .. .. . .. | %1 "-" )
		// .. .. . #1 AddExp() ]
		final NodeOptional n2 = n.f2;
		if (n2.present()) {
			final NodeSequence seq = (NodeSequence) n2.node;
			// #0 ( %0 "+"
			// .. | %1 "-" )
			final INode seq1 = seq.elementAt(0);
			final NodeChoice nch1 = (NodeChoice) seq1;
			final INode ich1 = nch1.choice;
			switch (nch1.which) {
			case 0:
				// %0 "+"
				nRes = ich1.accept(this);
				expTree = new ExpTreeNode(Operator.ADD, expTree);
				break;
			case 1:
				// %1 "-"
				nRes = ich1.accept(this);
				expTree = new ExpTreeNode(Operator.SUBTRACT, expTree);
				break;
			default:
				// should not occur !!!
				break;
			}
			// #1 AddExp()
			final INode seq2 = seq.elementAt(1);
			nRes = seq2.accept(this);
			expTree.add(nRes);
		}
		return expTree;
	}

	/**
	 * Visits a {@link MulExp} node, whose children are the following :
	 * <p>
	 * f0 -> PowExp()<br>
	 * f1 -> [ #0 ( %0 "*"<br>
	 * .. .. . .. | %1 "/"<br>
	 * .. .. . .. | %2 "\\"<br>
	 * .. .. . .. | %3 < MOD > )<br>
	 * .. .. . #1 MulExp() ]<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final MulExp n) {
		ExpTreeNode nRes = null;
		// f0 -> PowExp()
		final PowExp n0 = n.f0;
		nRes = n0.accept(this);
		ExpTreeNode expTree = nRes;
		// f1 -> [ #0 ( %0 "*"
		// .. .. . .. | %1 "/"
		// .. .. . .. | %2 "\\"
		// .. .. . .. | %3 < MOD > )
		// .. .. . #1 MulExp() ]
		final NodeOptional n1 = n.f1;
		if (n1.present()) {
			final NodeSequence seq = (NodeSequence) n1.node;
			// #0 ( %0 "*"
			// .. | %1 "/"
			// .. | %2 "\\"
			// .. | %3 < MOD > )
			final INode seq1 = seq.elementAt(0);
			final NodeChoice nch = (NodeChoice) seq1;
			final INode ich = nch.choice;
			switch (nch.which) {
			case 0:
				// %0 "*"
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.MULTIPLY, expTree);
				break;
			case 1:
				// %1 "/"
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.DIVIDE, expTree);
				break;
			case 2:
				// %2 "\\"
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.INTDIVIDE, expTree);
				break;
			case 3:
				// %3 < MOD >
				nRes = ich.accept(this);
				expTree = new ExpTreeNode(Operator.MODULO, expTree);
				break;
			default:
				// should not occur !!!
				break;
			}
			// #1 MulExp()
			final INode seq2 = seq.elementAt(1);
			nRes = seq2.accept(this);
			expTree.add(nRes);
		}
		return expTree;
	}

	/**
	 * Visits a {@link PowExp} node, whose children are the following :
	 * <p>
	 * f0 -> ItemExp()<br>
	 * f1 -> [ #0 "^" #1 PowExp() ]<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final PowExp n) {
		ExpTreeNode nRes = null;
		// f0 -> ItemExp()
		final ItemExp n0 = n.f0;
		nRes = n0.accept(this);
		ExpTreeNode expTree = nRes;
		// f1 -> [ #0 "^" #1 PowExp() ]
		final NodeOptional n1 = n.f1;
		if (n1.present()) {
			final NodeSequence seq = (NodeSequence) n1.node;
			// #0 "^"
			final INode seq1 = seq.elementAt(0);
			nRes = seq1.accept(this);
			// #1 PowExp()
			final INode seq2 = seq.elementAt(1);
			nRes = seq2.accept(this);
			expTree = new ExpTreeNode(Operator.POWER, expTree, nRes);
		}
		return expTree;
	}

	/**
	 * Visits a {@link ItemExp} node, whose child is the following :
	 * <p>
	 * f0 -> . %0 Literal()<br>
	 * .. .. | %1 #0 < IDENTIFIER ><br>
	 * .. .. . .. #1 [ &0 ( $0 "[" $1 Exp() $2 "]" )+<br>
	 * .. .. . .. .. | &1 $0 "(" $1 Exp()<br>
	 * .. .. . .. .. . .. $2 ( ?0 "," ?1 Exp() )*<br>
	 * .. .. . .. .. . .. $3 ")" ]<br>
	 * .. .. | %2 #0 "(" #1 Exp()<br>
	 * .. .. . .. #2 ( $0 "," $1 Exp() )*<br>
	 * .. .. . .. #3 ")"<br>
	 * .. .. | %3 #0 "{" #1 Exp() #2 "}"<br>
	 * .. .. | %4 #0 "[" #1 Exp() #2 "]"<br>
	 * .. .. | %5 #0 < SUMMATION > #1 ItemExp()<br>
	 * .. .. | %6 #0 < PRODUCT > #1 ItemExp()<br>
	 * .. .. | %7 #0 < COUNT > #1 ItemExp()<br>
	 * .. .. | %8 #0 < MAX > #1 ItemExp()<br>
	 * .. .. | %9 #0 < MIN > #1 ItemExp()<br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final ItemExp n) {
		ExpTreeNode nRes = null;
		// f0 -> . %0 Literal()
		// .. .. | %1 #0 < IDENTIFIER >
		// .. .. . .. #1 [ &0 ( $0 "[" $1 Exp() $2 "]" )+
		// .. .. . .. .. | &1 $0 "(" $1 Exp()
		// .. .. . .. .. . .. $2 ( ?0 "," ?1 Exp() )*
		// .. .. . .. .. . .. $3 ")" ]
		// .. .. | %2 #0 "(" #1 Exp()
		// .. .. . .. #2 ( $0 "," $1 Exp() )*
		// .. .. . .. #3 ")"
		// .. .. | %3 #0 "{" #1 Exp() #2 "}"
		// .. .. | %4 #0 "[" #1 Exp() #2 "]"
		// .. .. | %5 #0 < SUMMATION > #1 ItemExp()
		// .. .. | %6 #0 < PRODUCT > #1 ItemExp()
		// .. .. | %7 #0 < COUNT > #1 ItemExp()
		// .. .. | %8 #0 < MAX > #1 ItemExp()
		// .. .. | %9 #0 < MIN > #1 ItemExp()
		final NodeChoice nch = n.f0;
		final INode ich = nch.choice;
		ExpTreeNode expTree = null;
		switch (nch.which) {
		case 0:
			// %0 Literal()
			nRes = ich.accept(this);
			expTree = nRes;
			break;
		case 1:
			// %1 #0 < IDENTIFIER >
			// .. #1 [ &0 ( $0 "[" $1 Exp() $2 "]" )+
			// .. .. | &1 $0 "(" $1 Exp()
			// .. .. .. $2 ( ?0 "," ?1 Exp() )*
			// .. .. .. $3 ")" ]
			final NodeSequence seq = (NodeSequence) ich;
			// #0 < IDENTIFIER >
			final INode seq1 = seq.elementAt(0);
			nRes = seq1.accept(this);
			expTree = new ExpTreeNode(genVar((NodeToken) seq1, varClass, false));
			// #1 [ &0 ( $0 "[" $1 Exp() $2 "]" )+
			// .. | &1 $0 "(" $1 Exp()
			// .. .. $2 ( ?0 "," ?1 Exp() )*
			// .. .. $3 ")" ]
			final INode seq2 = seq.elementAt(1);
			final NodeOptional opt = (NodeOptional) seq2;
			if (opt.present()) {
				final NodeChoice nch1 = (NodeChoice) opt.node;
				final INode ich1 = nch1.choice;
				switch (nch1.which) {
				case 0:
					// &0 ( $0 "[" $1 Exp() $2 "]" )+
					final NodeList lst = (NodeList) ich1;
					for (int i = 0; i < lst.size(); i++) {
						final INode lsteai = lst.elementAt(i);
						final NodeSequence seq3 = (NodeSequence) lsteai;
						// $0 "["
						final INode seq4 = seq3.elementAt(0);
						nRes = seq4.accept(this);
						// $1 Exp()
						final INode seq5 = seq3.elementAt(1);
						nRes = seq5.accept(this);
						expTree = new ExpTreeNode(Operator.INDEX, expTree);
						expTree.add(nRes);
						// $2 "]"
						final INode seq6 = seq3.elementAt(2);
						nRes = seq6.accept(this);
					}
					break;
				case 1:
					// &1 $0 "(" $1 Exp()
					// .. $2 ( ?0 "," ?1 Exp() )*
					// .. $3 ")"
					expTree = new ExpTreeNode(Operator.INDEX, expTree);
					final NodeSequence seq7 = (NodeSequence) ich1;
					// $0 "("
					final INode seq8 = seq7.elementAt(0);
					nRes = seq8.accept(this);
					// $1 Exp()
					final INode seq9 = seq7.elementAt(1);
					nRes = seq9.accept(this);
					ExpTreeNode tmp = new ExpTreeNode(Operator.TUPLE, nRes);
					// $2 ( ?0 "," ?1 Exp() )*
					final INode seq10 = seq7.elementAt(2);
					final NodeListOptional nlo = (NodeListOptional) seq10;
					if (nlo.present()) {
						for (int i = 0; i < nlo.size(); i++) {
							final INode nloeai = nlo.elementAt(i);
							final NodeSequence seq11 = (NodeSequence) nloeai;
							// ?0 ","
							final INode seq12 = seq11.elementAt(0);
							nRes = seq12.accept(this);
							// ?1 Exp()
							final INode seq13 = seq11.elementAt(1);
							nRes = seq13.accept(this);
							tmp.add(nRes);
						}
					}
					expTree.add(tmp);
					// $3 ")"
					final INode seq14 = seq7.elementAt(3);
					nRes = seq14.accept(this);
					break;
				default:
					// should not occur !!!
					break;
				}
			}
			break;
		case 2:
			// %2 #0 "(" #1 Exp()
			// .. #2 ( $0 "," $1 Exp() )*
			// .. #3 ")"
			final NodeSequence seq15 = (NodeSequence) ich;
			// #0 "("
			final INode seq16 = seq15.elementAt(0);
			nRes = seq16.accept(this);
			// #1 Exp()
			final INode seq17 = seq15.elementAt(1);
			nRes = seq17.accept(this);
			// #2 ( $0 "," $1 Exp() )*
			final INode seq18 = seq15.elementAt(2);
			final NodeListOptional nlo1 = (NodeListOptional) seq18;
			if (nlo1.present()) {
				expTree = new ExpTreeNode(Operator.TUPLE, nRes);
				for (int i = 0; i < nlo1.size(); i++) {
					final INode nloeai = nlo1.elementAt(i);
					final NodeSequence seq19 = (NodeSequence) nloeai;
					// $0 ","
					final INode seq20 = seq19.elementAt(0);
					nRes = seq20.accept(this);
					// $1 Exp()
					final INode seq21 = seq19.elementAt(1);
					nRes = seq21.accept(this);
					expTree.add(nRes);
				}
			} else
				expTree = nRes;
			// #3 ")"
			final INode seq22 = seq15.elementAt(3);
			nRes = seq22.accept(this);
			break;
		case 3:
			// %3 #0 "{" #1 Exp() #2 "}"
			final NodeSequence seq23 = (NodeSequence) ich;
			// #0 "{"
			final INode seq24 = seq23.elementAt(0);
			nRes = seq24.accept(this);
			// #1 Exp()
			final INode seq25 = seq23.elementAt(1);
			nRes = seq25.accept(this);
			expTree = new ExpTreeNode(Operator.SET, nRes);
			// #2 "}"
			final INode seq26 = seq23.elementAt(2);
			nRes = seq26.accept(this);
			break;
		case 4:
			// %4 #0 "[" #1 Exp() #2 "]"
			final NodeSequence seq27 = (NodeSequence) ich;
			// #0 "["
			final INode seq28 = seq27.elementAt(0);
			nRes = seq28.accept(this);
			// #1 Exp()
			final INode seq29 = seq27.elementAt(1);
			nRes = seq29.accept(this);
			expTree = new ExpTreeNode(Operator.ARRAY, nRes);
			// #2 "]"
			final INode seq30 = seq27.elementAt(2);
			nRes = seq30.accept(this);
			break;
		case 5:
			// %5 #0 < SUMMATION > #1 ItemExp()
			final NodeSequence seq31 = (NodeSequence) ich;
			// #0 < SUMMATION >
			final INode seq32 = seq31.elementAt(0);
			nRes = seq32.accept(this);
			// #1 ItemExp()
			final INode seq33 = seq31.elementAt(1);
			nRes = seq33.accept(this);
			sumCnt++;
			VarRecord newVar = varTable.newVar("_sum" + sumCnt, VarClass.INDEPENDENT);
			expTree = new ExpTreeNode(Operator.EQUAL, new ExpTreeNode(newVar),
					new ExpTreeNode(Operator.SUMMATION, nRes));
			expTree.setAccV(newVar);
			expTrees.add(expTree);
			expTree = expTree.getSons().get(0);
			break;
		case 6:
			// %6 #0 < PRODUCT > #1 ItemExp()
			final NodeSequence seq34 = (NodeSequence) ich;
			// #0 < PRODUCT >
			final INode seq35 = seq34.elementAt(0);
			nRes = seq35.accept(this);
			// #1 ItemExp()
			final INode seq36 = seq34.elementAt(1);
			nRes = seq36.accept(this);
			expTree = new ExpTreeNode(Operator.PRODUCT, nRes);
			// TODO add tmpVar
			break;
		case 7:
			// %7 #0 < COUNT > #1 ItemExp()
			final NodeSequence seq37 = (NodeSequence) ich;
			// #0 < COUNT >
			final INode seq38 = seq37.elementAt(0);
			nRes = seq38.accept(this);
			// #1 ItemExp()
			final INode seq39 = seq37.elementAt(1);
			nRes = seq39.accept(this);
			expTree = new ExpTreeNode(Operator.COUNT, nRes);
			// TODO add tmpVar
			break;
		case 8:
			// %8 #0 < MAX > #1 ItemExp()
			final NodeSequence seq40 = (NodeSequence) ich;
			// #0 < MAX >
			final INode seq41 = seq40.elementAt(0);
			nRes = seq41.accept(this);
			// #1 ItemExp()
			final INode seq42 = seq40.elementAt(1);
			nRes = seq42.accept(this);
			expTree = new ExpTreeNode(Operator.MAX, nRes);
			// TODO add tmpVar
			break;
		case 9:
			// %9 #0 < MIN > #1 ItemExp()
			final NodeSequence seq43 = (NodeSequence) ich;
			// #0 < MIN >
			final INode seq44 = seq43.elementAt(0);
			nRes = seq44.accept(this);
			// #1 ItemExp()
			final INode seq45 = seq43.elementAt(1);
			nRes = seq45.accept(this);
			expTree = new ExpTreeNode(Operator.MIN, nRes);
			// TODO add tmpVar
			break;
		default:
			// should not occur !!!
			break;
		}
		return expTree;
	}

	/**
	 * Visits a {@link Literal} node, whose child is the following :
	 * <p>
	 * f0 -> . %0 < INT_LITERAL ><br>
	 * .. .. | %1 < REAL_LITERAL ><br>
	 * .. .. | %2 < BOOL_LITERAL ><br>
	 * .. .. | %3 < CHAR_LITERAL ><br>
	 * .. .. | %4 < STRING_LITERAL ><br>
	 *
	 * @param n - the node to visit
	 * @return the user return information
	 */
	@Override
	public ExpTreeNode visit(final Literal n) {
		// f0 -> . %0 < INT_LITERAL >
		// .. .. | %1 < REAL_LITERAL >
		// .. .. | %2 < BOOL_LITERAL >
		// .. .. | %3 < CHAR_LITERAL >
		// .. .. | %4 < STRING_LITERAL >
		final NodeChoice nch = n.f0;
		final INode ich = nch.choice;
		ExpTreeNode expTree = null;
		switch (nch.which) {
		case 0:
			ich.accept(this);
			expTree = new ExpTreeNode(new VarTypeInt(((NodeToken) ich).tokenImage), ((NodeToken) ich).tokenImage);
			break;
		case 1:
			ich.accept(this);
			expTree = new ExpTreeNode(new VarTypeReal(((NodeToken) ich).tokenImage), ((NodeToken) ich).tokenImage);
			break;
		case 2:
			ich.accept(this);
			expTree = new ExpTreeNode(new VarTypeBool(((NodeToken) ich).tokenImage), ((NodeToken) ich).tokenImage);
			break;
		case 3:
			ich.accept(this);
			expTree = new ExpTreeNode(new VarTypeChar(((NodeToken) ich).tokenImage), ((NodeToken) ich).tokenImage);
			break;
		case 4:
			ich.accept(this);
			expTree = new ExpTreeNode(new VarTypeArray(((NodeToken) ich).tokenImage), ((NodeToken) ich).tokenImage);
			break;
		default:
			// should not occur !!!
			break;
		}
		return expTree;
	}

}
